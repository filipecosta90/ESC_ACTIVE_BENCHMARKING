
% !TEX encoding = UTF-8 Unicode



\documentclass[a4paper]{article}
\usepackage{dirtytalk}
\usepackage{geometry}
\geometry{
 a4paper,
 total={150mm,247mm},
 left=30mm,
 top=30mm,
 }
\usepackage{quotchap}

\usepackage{graphicx}
\usepackage{epstopdf}
\DeclareGraphicsExtensions{.eps}
\usepackage{url}
\usepackage{multicol}% http://ctan.org/pkg/multicols
\usepackage{epigraph}
\setlength{\epigraphwidth}{.85\textwidth}

\usepackage[utf8x]{inputenc} 

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{listings,mdframed}

\usepackage{textcomp}
\usepackage{hyperref}

\usepackage{float}
\usepackage{listings}

\lstdefinestyle{esc} {
language=c,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\tiny,
numberstyle=\small,
numbers=right,
	stepnumber=1,
	numbersep=10pt,
	tabsize=1,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	%aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true,
 frame=single,
}

\lstdefinestyle{command}{
backgroundcolor=\color{yellow},frame=shadowbox,
language=c,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\small,
numberstyle=\small,
numbers=right,
	stepnumber=1,
	numbersep=10pt,
	tabsize=1,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	%aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true,
}

\lstset{
	language=c,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\small,
numberstyle=\small,
numbers=right,
	stepnumber=1,
	numbersep=10pt,
	tabsize=1,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	%aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true,
 frame=single
 %backgroundcolor=\color{lbcolor},
}

\usepackage{titling}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}


\begin{document}
\title{Performance e Precisão Relativas de Filesystem Benchmarks e Disk Benchmarks}

\subtitle{Active Benchmarking da ferramenta iozone recorrendo a DTrace em Solaris 11}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{{Filipe Oliveira}
Departamento de Informática\\
Universidade do Minho\\
Email: a57816@alunos.uminho.pt}
}



% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
%\begin{abstract}

%Neste estudo, analisamos a performance de kernels 
%\end{abstract}

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.



%\section{Introduction}
% no \IEEEPARstart
%This demo file is intended to serve as a ``starter file''
%for IEEE Computer Society conference papers produced under \LaTeX\ using
%IEEEtran.cls version 1.8b and later.
% You must have at least 2 lines in the paragraph with the drop letter
% (should never be an issue)
%I wish you the best of success.

%\hfill Filipe Oliveira
 
%\hfill 1 Março, 2016
\renewcommand{\abstract}{\textbf{\centering Introdução -- Contextualização da Ferramenta iozone\break}}

\abstract{

A necessidade de recurso a ferramentas de Benchmarking está implicitamente associada à necessidade de recolha de informação dos sistemas de computação no seu todo, ou de pontos específicos do mesmo, e sua posterior comparação e interpretação. Ora, quando queremos estudar especificamente a performance de um sistema de ficheiros e/ou de um determinado tipo de dispositivo de armazenamento de informação, podemos recorrer a ferramentas de traçado dinâmico (como o dtrace) por forma a confirmar os resultados obtidos e/ou complementar os mesmos, de uma forma que outrora era de extrema complexidade e dificuldade. \par 
É importante realçar que a performance relativa dos sistemas de ficheiros e dispositivos de armazenamento está implicitamente ligada, uma vez que através de caching, buffering, e I/O assíncrono um sistema de ficheiros poderá "esconder" do nível da aplicação determinadas propriedades e lacunas do dispositivo físico de armazenamento. Retornando às ferramentas de benchmarking de sistemas de ficheiros e/ou dispositivos de armazenamento podemos compreender que as técnicas de software/hardware de otimização de tempos acesso aos dados, poderão implicar a benchmarking pouco precisa dos sistemas físicos presentes no sistema. \par 
Todos os métodos de redução de tempos de acesso, ou seja, todos os métodos que tentam esconder a latência de acesso aos dados, deverão ser tidas em contacto no momento do benchmarking. Este trabalho prende-se precisamente com o estudo do quão precisa é a ferramenta de benchmarking iozone em sistemas de computação Solaris based, nomeadamente na máquina descrita na tabela \ref{table:characterization}.


\begin{table}[H]
\caption{Características de Hardware do sistema de computação }
     \label{table:characterization}
\centering
  \begin{tabular}{ | l | r | }
  
    \hline
    Sistema & compute-641 \\ \hline \hline
        \# CPUs & 2  \\ \hline
    CPU & Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered}  E5-2650 v2 \\ \hline 
    Arquitectura de Processador & Ivy Bridge  \\ \hline 
    \# Cores por CPU & 8   \\ \hline 
    \# Threads por CPU & 16  \\ \hline 
     Freq. Clock & 2.6 GHz  \\ \hline
    Cache L1  & 256KB  (32KB por Core)  \\ \hline 
    Cache L2  & 2048KB (256KB por Core)  \\ \hline 
    Cache L3  & 20480KB (partilhada) \\ \hline 
  Ext. Inst. Set  & SSE4.2, AVX  \\ \hline 
         \#Memory Channels & 4 \\ \hline
        Memória Ram Disponível & 64GB \\ \hline
     Peak Memory BW Fab. CPU  & 59.7 GB/s \\ \hline
     \textbf{Local FileSystems} & ufs \\ \hline
    \textbf{ NFS FileSystems} & nfs,
smb, 
autofs, 
smbfs\\ \hline
  \end{tabular}
\end{table}

Aquando da realização de benchmarking via iozone, iremos recorrer a outras ferramentas (nomeadamente truss e dtrace) para procedermos à nossa própria benchmark -- vulgo Active Benchmarking. Pretendemos com isso determinar quais os principais "bottlenecks" da porção do sistema a analisar, e ao mesmo tempo desenvolver capacidade crítica na análise de dados relativos a performance de sistemas de computação de complexidade acrescida.\par 
Precisamos primeiramente de analisar de uma forma geral o comportamento da aplicação iozone no que  concerne a system calls, traçando de seguida um plano de traçado dinâmico que corrobore/desminta o apresentado pela ferramenta. 
I
\section{Passive Benchmarking :: uma primeira análise à ferramenta}

Definida a ferramenta de benchmarking - iozone - existem diferentes opções a ter em conta, nomeadamente:
\begin{itemize}
\item tipo de operação -- read, write, re-read, re-write, e outros
\item tamanho do I/O
\item forma de acesso aos dados -- sequencial ou random
\item Memory mapping -- acesso á memória mmap em detrimento de read/write.
\end{itemize}
Teremos que ter ainda em conta na escolha do tamanho do dataset a memória disponível, assim como a quantidade dados passíveis de estarem presentes na memória cache. Só assim conseguiremos garantir que o recurso a uma system call irá resultar numa leitura/escrita em disco, ultrapassando os vários níveis de disfarce de latência.\par 
Ora, dado que é na escrita dos dados que acreditamos que existirá uma maior possibilidade de descrepância de resultados pelo iozone versus os que iremos obter por medição direta (dados os inúmeros mecanismos como caching, buffering, e I/O assíncrono, permitirem a uma kernel efectuar uma escrita sem necessariamente os dados serem imediatamente escritos no disco), tomaremos especial atenção à performance de escrita medida pela ferramenta.\par 
Ora, e atendendo ao seguinte excerto das Iozone Run rules:

\epigraph{\textbf{For disk performance comparisons:}\par 
1. For single stream results, be sure the file size is 3 times the size of the buffer cache. For throughput results, be sure the aggregate of files is 3 times the size of the buffer cache.\\\url{}}

Daqui retiramos que o tamanho do ficheiro deverá ser 3 vezes superior à buffer cache disponível nos sistema de computação. Precisamos portanto de determinar esse valor, dado pelo parâmetro \textbf{UFS bufhwm}. Atente na sua descrição:

\epigraph{\textbf{UFS Parameters}\\
\textbf{bufhwm and bufhwm\_pct}\\
\textbf{Description:}\par 

Defines the maximum amount of memory for caching I/O buffers. The buffers are used for writing file system metadata (superblocks, inodes, indirect blocks, and directories). Buffers are allocated as needed until the amount of memory (in KB) to be allocated exceed bufhwm. At this point, metadata is purged from the buffer cache until enough buffers are reclaimed to satisfy the request.
\vspace{3mm}\\ \url{http://docs.oracle.com/cd/E23823_01/html/817-0404/chapter2-37.html}}

Ora, recorrendo ao comando \textbf{sysdef} podemos extrair a informação desejada:

\begin{lstlisting}[style=command]
 sysdef
 ...
*
* Tunable Parameters
*
1373298688	maximum memory allowed in buffer cache (bufhwm)
...
   \end{lstlisting}
   
Poderíamos ser induzidos em erro e considerar como 3 * 1373298688 KB o tamanho do ficheiro a utilizar. Contudo, um olhar mais atento à continuação da definição de \textbf{bufhwm}:
\epigraph{


\textbf{Range}\\ 
80 KB to 20 percent of physical memory, or 2 TB, whichever is less. Consequently, bufhwm\_pct can be between 1 and 20.\\

\textbf{Validation}\\
If bufhwm is less than its lower limit of 80 KB or \textbf{greater than its upper limit} (the lesser of 20 percent of physical memory, 2 TB, or one quarter (1/4) of the maximum amount of kernel heap), it is reset to the upper limit. The following message appears on the system console and in the /var/adm/messages file if an invalid value is attempted:
\vspace{3mm}\\ \url{http://docs.oracle.com/cd/E23823_01/html/817-0404/chapter2-37.html}}\par 
leva-nos a calcular o valor máximo de bufhwm como ( 20\% de 65501000 KB )  * 3 =  39300600 KB = 39.3006 GB. 
\par 

\subsection{Command Line Options}
Analisando ainda as \say{Command Line Options} da ferramenta podemos desde já enumerar algumas opções que devemos incluir:

\begin{itemize}
\item \textbf{ -i 0 } -- Used to specify which tests to run. (0=write/rewrite, 1=read/re-read, 2=random-read/write 3=Read-backwards, 4=Re-write-record, 5=stride-read, 6=fwrite/re-fwrite, 7=fread/Re-fread, 8=random mix, 9=pwrite/Re-pwrite, 10=pread/Re-pread, 11=pwritev/Re-pwritev, 12=preadv/Re- preadv).

\item \textbf{-s 39g} -- Used to specify the size, in Kbytes, of the file to test. One may also specify -s #k (size in Kbytes) or -s #m (size in Mbytes) or -s #g (size in Gbytes). 

\item \textbf{-S 20480} -- Set processor cache size to value (in Kbytes). This tells Iozone the size of the processor cache. It is used internally for buffer alignment and for the purge functionality.

\item \textbf{-l 1 } -- Set the lower limit on number of processes to run. When running throughput tests this option allows the user to specify the least number of processes or threads to start. This option should be used in conjunction with the -u option.

\item \textbf{-u 1 } -- Set the upper limit on number of processes to run. When running throughput tests this option allows the user to specify the greatest number of processes or threads to start. This option should be used in conjunction with the -l option.

\item \textbf{ -b /export/home/a57816/ESC\_ACTIVE\_BENCHMARKING\_HOME/teste\_write.xls } -- Iozone will create a binary file format file in Excel compatible output of results.

\item \textbf{-R} -- Generate Excel report. Iozone will generate an Excel compatible report to standard out. This file may be imported with Microsoft Excel (space delimited) and used to create a graph of the filesystem performance. Note: The 3D graphs are column oriented. You will need to select this when graphing as the default in Excel is row oriented data.
\end{itemize}

Assim, analisemos resultado  do seguinte comando iozone:
\begin{lstlisting}[style=command]
/opt/csw/bin/iozone -+u -R -i 0 -S 20480 -s 39g -b /export/home/a57816/ESC_ACTIVE_BENCHMARKING_HOME/teste_write.xls -l 1 -u 1 
\end{lstlisting}
   
que apresenta o seguinte resultado:
\begin{lstlisting}
	Iozone: Performance Test of File I/O
	        Version $Revision: 3.434 $
		Compiled for 64 bit mode.
		Build: Solaris10 

	Contributors:William Norcott, Don Capps, Isom Crawford, Kirby Collins
	             Al Slater, Scott Rhine, Mike Wisner, Ken Goss
	             Steve Landherr, Brad Smith, Mark Kelly, Dr. Alain CYR,
	             Randy Dunlap, Mark Montague, Dan Million, Gavin Brebner,
	             Jean-Marc Zucconi, Jeff Blomberg, Benny Halevy, Dave Boone,
	             Erik Habbinga, Kris Strecker, Walter Wong, Joshua Root,
	             Fabrice Bacchella, Zhenghua Xue, Qin Li, Darren Sawyer,
	             Vangel Bojaxhi, Ben England, Vikentsi Lapa,
	             Alexey Skidanov.

	Run began: Mon Apr 18 19:34:12 2016

	CPU utilization Resolution = 0.000 seconds.
	CPU utilization Excel chart enabled
	Excel chart generation enabled
	File size set to 40894464 kB
	Command line used: /opt/csw/bin/iozone -+u -R -i 0 -S 20480 -s 39g -b /export/home/a57816/ESC_ACTIVE_BENCHMARKING_HOME/teste_write.xls -l 1 -u 1
	Output is in kBytes/sec
	Time Resolution = 0.000001 seconds.
	Processor cache size set to 20480 kBytes.
	Processor cache line size set to 32 bytes.
	File stride size set to 17 * record size.
	Min process = 1 
	Max process = 1 
	Throughput test with 1 process
	Each process writes a 40894464 kByte file in 4 kByte records

	Children see throughput for  1 initial writers 	=  489166.09 kB/sec
	Parent sees throughput for  1 initial writers 	=  406767.30 kB/sec
	Min throughput per process 			=  489166.09 kB/sec 
	Max throughput per process 			=  489166.09 kB/sec
	Avg throughput per process 			=  489166.09 kB/sec
	Min xfer 					= 40894464.00 kB
	CPU Utilization: Wall time   83.600    CPU time   77.460    CPU utilization  92.65 %


	Children see throughput for  1 rewriters 	=  463768.00 kB/sec
	Parent sees throughput for  1 rewriters 	=  402978.57 kB/sec
	Min throughput per process 			=  463768.00 kB/sec 
	Max throughput per process 			=  463768.00 kB/sec
	Avg throughput per process 			=  463768.00 kB/sec
	Min xfer 					= 40894464.00 kB
	CPU utilization: Wall time   88.179    CPU time   71.719    CPU utilization  81.33 %




"Throughput report Y-axis is type of test X-axis is number of processes"
"Record size = 4 kBytes "
"Output is in kBytes/sec"

"  Initial write "  489166.09 

"        Rewrite "  463768.00 


"CPU utilization report Y-axis is type of test X-axis is number of processes"
"Record size = 4 kBytes "
"Output is in CPU%"

"  Initial write "      92.65 

"        Rewrite "      81.33 


iozone test complete.
\end{lstlisting}
 
 \subsection{Take 1 -- uma análise com truss}
Ora, dos resultados anteriores, retiramos que o máximo de throughput do sistema de ficheiros e dispositivo de armazenamento físico tem o valor de 489166.09 KB/s para operações de escrita e 463768.00 KB/s para operações de re-escrita. Este último resultado apresentado leva-nos a duvidar da precisão de medição da ferramenta. Outro indicador que nos leva a duvidar da veracidade da medição prende-se com os valores altíssimos de utilização de CPU time de uma aplicação implicitamente \textbf{IO BOUND}.\par 
Analisemos o tipo de system calls realizada pela ferramenta recorrendo ao seguinte comando \textbf{truss}:

\begin{lstlisting}[style=command]
truss -o truss_report_write.txt -df /opt/csw/bin/iozone -+u -R -i 0 -S 20480 -s 39g -b /export/home/a57816/ESC_ACTIVE_BENCHMARKING_HOME/teste_write.xls -l 1 -u 1 
\end{lstlisting}


\newpage
\section{Conclusão}
Tal como mencionado no início do presente caso de estudo a ferramenta DTrace mostra-se bastante útil e única em termos de funcionalidades quando necessitamos de agregar informação de vários processos/threads,etc. Ou seja, no contexto da computação paralela será extremamente interessante recorrer a esta ferramenta de traçado dinâmico na execução de algoritmos paralelos. \par 
Este foi apenas um trabalho introdutório mas permitiu demostrar a capacidade de recolher e ao mesmo tempo tratar dados de todo um sistema extremamente complexo e vasto com apenas uma ferramenta. O caso de estudo ultrapassa portanto os resultados obtidos pelas scripts geradas, prendendo-se uma vez mais com o desenvolvimento de capacidade  prática no uso da ferramenta, e envolvimento com métodos de tratamento de grandes volumes de dados, e análise de métricas de sistemas de computação de alta perfomance.\par Retrata sobretudo a capacidade analisar funcionalidades disponibilizadas e a sua correta aplicação na resolução de problemas de computação tendo sempre em conta o mínimo de alteração possível na performance dos kernels/sistemas a analisar.




\end{document}


